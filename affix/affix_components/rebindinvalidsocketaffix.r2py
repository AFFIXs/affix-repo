#!python
"""
<Library Name>
  rebindinvalidsocketaffix.repy

<Purpose>
  The purpose of this library is to create a new 
  tcp listening server socket if the old server
  socket becomes invalid at some point. If the old
  socket becomes invalid due to some state changin
  in the stack below (ip address change, disconnected
  from forwarders etc.), then we will no longer be able
  to accept new incoming connections. Thus we need
  to create a new listening socket that is fresh,
  so we are able to accept new incoming connections.

<Author>
  Monzur Muhammad
  monzum@cs.washington.edu

<Started>
  5/8/2014

<Histor>
  5/8/2014 - Initial library implemented.
"""

baseaffix = dy_import_module("baseaffix.r2py")


class RebindInvalidSocketAffix(baseaffix.BaseAffix):
  """
  A affix that creates a new listening socket if the
  current server socket becomes invalid. 

  """

  def listenforconnection(self, localip, localport):
    # When listenforconnection() is called, we store
    # the arguments that are passed in, so we can 
    # re-create the listening socket in the future
    # if the current listening socket becomes invalid.
    self.localip = localip
    self.localport = localport

    next_layer_socket = self.peek().listenforconnection(localip, localport)
    return baseaffix.AffixTCPServerSocket(next_layer_socket, self)


  def tcpserversocket_getconnection(self, tcpserversocket):
    # We make a copy of ourselves before doing a getconnection
    # as this function may be invoked multiple times and each
    # individual socket may each modify the affix stack 
    # below it differently. 
    this_affix_copy = self.copy()
    try:
      (remote_ip, remote_port, repy_socket) = this_affix_copy.peek().tcpserversocket_getconnection(tcpserversocket)
    except TCPServerSocketInvalidError:
      # The current listening socket is no longer valid and
      # will no longer be able to accept an incoming connection.
      # So we will recreate a new listening socket using the
      # original arguments. After creating the new socket, we
      # modify the AffixTCPServerSocket to use the new server
      # socket that we just created. First we close the current
      # socket locally, to ensure that it is cleaned up before
      # we try to rebind to the same IP:port.
      tcpserversocket.close()
      new_tcp_server_sock = self.peek().listenforconnection(self.localip, self.localport)
      tcpserversocket._socket = new_tcp_server_sock  


      # Now that we have the new serversocket, lets try calling 
      # getconnection again with the new tcpserversocket.
      (remote_ip, remote_port, repy_socket) = this_affix_copy.peek().tcpserversocket_getconnection(new_tcp_server_sock)


    return (remote_ip, remote_port, AffixSocket(repy_socket, self))




  def copy(self):
    if self.affix_context['next_affix']:
      next_affix_copy = self.affix_context['next_affix'].copy()
    else:
      next_affix_copy = None
    return RebindInvalidSocketAffix(next_affix_copy, self.affix_context['optional_args'])


  
  def get_advertisement_string(self):
    return self.peek().get_advertisement_string()
