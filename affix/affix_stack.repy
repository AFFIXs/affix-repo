#!python
"""
<Program Name>
  affix_stack.repy

<Author>
  Monzur Muhammad, monzum@cs.washington.edu

<Date Started>
  March 2011

<Purpose>
  This module creates and maintains a stack of affixs which
  can be used to alter network calls in various ways.

  The user creates a affix stack object by providing a string
  which contains the list of affixs in order that they should be
  used with all their arguments.

  The stack holds the affixs in order and each of the affixs in the
  stack also has a reference to where it is in the stack. This way
  each of the affix is able to know all the affixs that are below it
  in the stack. An example affix stack will look like:

              Affix Stack
          -----------------
          |  ===========  |
          |  =  AffixA =  |
          |  ===========  |
          |       |       |
          |       V       |
          |  ===========  |
          |  =  AffixB =  |
          |  ===========  |
          |       |       |
          |       V       |
          |  ===========  |
          |  =  AffixC =  |
          |  ===========  |
          -----------------
                  |
                  V
       -----------------------
       Original Repy API calls
       -----------------------


  In this case AffixA is able to see both AffixB and AffixC. AffixB is 
  able to see only AffixC, and AffixC is not able to see any of the affix. 

  When writing a new affix, it must inherit from BaseAffix (baseaffix.repy)
  and the file name must be all lowercase with no space or symbole in 
  file name. For example AffixA must have a filename affixa.repy This 
  particular naming convention is used so that AffixStack can dynamically 
  import all the affix files that are necessary without the user explicitly
  importing the affix files.

<History>
  03-07-2011: Renewed implementation of AffixStack.repy
  09-20-2012: Changed copy() to make sure it doesn't still have old reference.
              Changed peek() to make sure it doesn't use copy().
"""


# Import the affix exceptions.
dy_import_module_symbols("affix_exceptions")

# A dictionary that holds all the affix objects that have been
# registered. This dictionary is shared globally by all AffixStacks
# because we need to register each affix only once.
AFFIX_CLASS_DICT = {}


# We have this function outside so each affix gets registed only once
# globaly. Otherwise we might run into some import error.
def find_and_register_affix(affix_name):
  """
  <Purpose>
    Given a affix, this function imports the affix file
    if it exists and then registers the affix class.
    Note that the expected naming convention of the affix
    files is that it will be all lower-case with no space
    or symbols in the name. 

    Example:
        If we have a affix called ExampleAffix then the file
        name is expected to be exampleaffix.repy

        ExampleAffix.repy, example_affix.repy or any other 
        forms are unaccepted.

  <Arguments>
    affix_name - The name of the affix that must be imported 
        and registered.

  <Side Effects>
    Repy library file is imported.

  <Exceptions>
    AffixNotFoundError - raised if the requested affix_name does
        not exist or is not in the current directory.

    AssertionError - raised if arguments provided is of an 
        unexpected type or value.
  <Return>
    None
  """

  assert(isinstance(affix_name, str)), "Bad arg type. affix_name must be a string."

  # If the affix class has already been registered, then we don't
  # need to do anything.
  if affix_name in AFFIX_CLASS_DICT.keys():
    return

  # We have to do the import in a while loop in case we get the 
  # FileInUseError. This error occurs when multiple affix stacks
  # may be trying to load the affix.
  while True:
    # Try to import the affix file. We convert the name to 
    # lower case before importing.
    try:
      if affix_name not in _context.keys():
        dy_import_module_symbols(affix_name.lower())
    except FileInUseError, err:
      sleep(0.01)
    else:
      break

  # Register the affix.
  AFFIX_CLASS_DICT[affix_name] = _context.copy()[affix_name]    
          



# Register the base affix class before doing anything.
# The base affix is used by all other affixs.
find_and_register_affix('BaseAffix')    





# ======================================================================================================
# AffixStack Class - The main AffixStack class that is used.
# ======================================================================================================



class AffixStack:


  def __init__(self, affix_stack_str='', localhost=None):
    """
    <Purpose>
      Initialize the stack of affixs. Parse the affix stack string
      and create the stack from it.
  
    <Arguments>
      affix_stack_str - A string that contains all the affixs that
          are going to be used, and the order that they will be
          used in.

      localhost - Its the ip/hostname that this machine will be 
          known by. It should be a string.

    <Side Effects>
      None

    <Exceptions>
      AffixArgumentError - raised if the arguments provided is not
          the expected value or type.

      AffixConfigError - raised if unable to parse affix string.

    <Return>
      None
    """

    # This is the context that will keep track of the state of this
    # affix stack. 
    self.affix_stack_context = {}
    self.affix_stack_context['localhost'] = 'localhost'
    self.affix_stack_context['top_affix'] = None
    self.affix_stack_context['affix_str'] = '' 
    self.affix_stack_context['affix_class'] = {}
  

    
    # Ensure that if the localhost was provided then it is in
    # the string form. Note that we don't check the data type 
    # for affix_stack_str as it is checked in the function
    # make_affix_stack()
    if localhost and not isinstance(localhost, str):
      raise AffixArgumentError("The 'localhost' provided must be a string.")

    self.make_affix_stack(affix_stack_str, self.affix_stack_context['top_affix'])

    self.affix_stack_context['localhost'] = localhost
    self.affix_stack_context['affix_str'] = affix_stack_str





# ==================================================================================
# Public Methods - Used by developers to manipulate affix stack.
# ==================================================================================

  def push(self, affix_object):
    """
    <Purpose>
      Add the affix_object to the top of the stack.

    <Arguments>
      affix_object - the affix that needs to be added to the stack.

    <Side Effects>
      The stack of the current top affix gets modified

    <Exceptions>
      AffixStackError - raised if unable to add affix_object to stack.
    
    <Return>
      None
    """
    
    # Monzur: The affix objects are of different class types. They all inherit from
    # BaseAffix but is there a way to check if its a proper affix object?

    # Get the top affix of this stack.
    cur_top_affix = self.affix_stack_context['top_affix']

    # If this is the first layer of affix and nothing has been 
    # added to the stack yet.
    if cur_top_affix: 
      # If the current stack is not empty, we push the top affix to
      # the new affix objects stack, and then make the new affix object
      # the new top affix.
      affix_object.affix_context['affix_stack'].push(cur_top_affix)

    self.affix_stack_context['top_affix'] = affix_object


      



  def pop(self):
    """
    <Purpose>
      Remove and return the very top affix layer from the affix stack.
      If stack is empty, it raises an error

    <Arguments>
      None

    <Side Effects>
      Stack gets modified.

    <Exception>
      AffixStackError - raised if the affix stack is empty.

    <Return>
      The top layer affix object.
    """

    # This function is equivalent to:
    #     old_root = root
    #     root = old_root.next
    #     return old_root
   
    top_affix = self.affix_stack_context['top_affix']
    
    if not top_affix:
      raise AffixStackError("Affix stack is empty. Cannot pop() from stack.")

    # Equivalent to top_affix = top_affix.next_affix()
    self.affix_stack_context['top_affix'] = top_affix.affix_context['affix_stack'].affix_stack_context['top_affix']

    # Monzur - Before we return the top_affix, should we point top_affixs affix
    # stack to None? User may be able to modify the current affix stack because 
    # the top_affix that is returned has reference to the rest of the stack. 
    # Or perhaps we should return a copy() of the top affix?

    return top_affix





  def peek(self):
    """
    <Purpose>
      Return a copy of the top affix.

    <Arguments>
      None

    <Side Effects>
      None

    <Exception>
      AffixStackError - raised if affix stack is empty.

    <Return>
      A copy of the top affix.
    """

    if not self.affix_stack_context['top_affix']:
      raise AffixStackError("Affix stack is empty. Cannot peek() from stack.")

    # Monzur - Should we return a copy here or should we return the original
    # affix object? Right now I am returning a copy so peek() cannot be used
    # to modify anything below this affix.    
    # copy_top_affix = self.affix_stack_context['top_affix'].copy()

    # Monzur - I decided to send the reference to the actual affix stack
    # as it seems reasonable that peek should be able to be used to modify
    # the affix stack below it.
    return self.affix_stack_context['top_affix']





  def deepcopy(self):
    """
    <Purpose>
      Does a hard copy of self recursively and returns it.

    <Arguments>
      None

    <Side Effects>
      A new AffixStack object is created.

    <Exception>
      None

    <Return>
      A AffixStack object. It is deepcopy of self.
    """

    # In order to do a deepcopy() of the stack, we need to go through
    # every single AFFIX component in the stack and create a copy of 
    # it. We cannot use the AFFIX string to build the copy as AFFIX
    # components might have been copied or deleted since this stack
    # was initialized.

    # If the current stack is empty, then we have reached the bottom
    # and can return an empty stack, otherwise we will copy the top
    # AFFIX component and push it on to the new empty stack.
    new_stack = AffixStack()
    try:
      top_affix = self.peek()
    except AffixStackError, err:
      pass
    else:
      new_stack.push(top_affix.copy())
      new_stack.affix_stack_context['affix_str'] = self.affix_stack_context['affix_str']
    

    return new_stack





  def gethostname(self): 
    return self.affix_stack_context['localhost']


# =========================== End of Public Methods ================================



  def make_affix_stack(self, affix_str, stack_object):
    """
    <Purpose>
      Recursively build up a affix stack from a affix string.

    <Arguments>
      affix_str - a affix string used to build affix stack.
      stack_object - the current affix stack.

    <Side Effects>
      None

    <Exceptions>
      AffixNotFoundError - Raised if one of the affixs in the 
          affix_str is not a valid affix or the affix file could
          not be found.
 
      AffixConfigError - raised if affix string is not in the right
          format.

      AssersionError - may be raised if one of the arguments provided
          is an unexpected type or value.

    <Return>
      A affix stack list or none if affix_str is empty.
    """


    # Some sanity checks.
    assert(isinstance(affix_str, str)), "Bad arg type. affix_str must be a string."
    
    # We are going to work our way up from the bottom. So we 
    # recursively go to the bottom of the stack and then
    # start constructiong the affixs and then add them to the
    # stack. That way the first item in the affix_str will be
    # at the top of the stack. 

    # Base case. If we have reached the bottom of the stack
    # then we add in an AFFIX that is basically a wrapper 
    # around the Repy network API. This allows us to make
    # actual network calls when we have reached the bottom
    # of the stack.
    if not affix_str:
      return None
      # We were previously pushing down the RepyNetworkApiWrapper
      # onto a stack in order to resolve issue #11. Until further
      # discussion, we will not be not adding the wrapper on to
      # the stack.
      # self.push(RepyNetworkApiWrapper())
      

    # Build stack recursively. Any exceptions raised will just
    # percolate up. This may raise a AffixConfigError
    top_affix_name, affix_args, leftover_affix_str = self.parse_affix_string(affix_str)


    # Ensure the first argument is a legit string. If it is, we are going to load
    # the affix file if we find it. We assert and register the affix before building
    # the rest of the stack in order to fail early if we are unable to register
    # the top affix.
    assert(isinstance(top_affix_name, str)), "Bad arg type. First arg in affix tuple must be string."
    find_and_register_affix(top_affix_name)

    # Create a affix stack for the rest of the affixs below us, 
    # make that our current affix stack. After we create the affix 
    # stack with the leftover affix_str we are going to copy over
    # the new AffixStack objects stack_object to our own stack_object.
    # After we have copied it, we can now push on the top affix on top
    # of it.
    next_affix_object = self.make_affix_stack(leftover_affix_str)

    # Create the new affix object.
    # The new stack will have a copy of the affixstack before this 
    # layer is added. So if this is the first layer, then the 
    # Underlying stack beneath it would be None.
    new_affix = self.create_affix_object(top_affix_name, affix_args, next_affix_object)


    # Link the top affix to the affix stack object. This makes top_affix
    # the root/head of the affix stack. Even though it is called a affix
    # stack, the internals of the stack will work like a linked list.
    #self.push(top_affix)

    # Return the top affix. Do we need to return anything? I am returning for convenience.
    # If this is the first layer then our peek may be empty.
    return new_affix
    




  def create_affix_object(self, affix_name, affix_args, next_affix_object):
    """
    <Purpose>
      Create an affix object given a affix name and its arguments.

    <Arguments>
      affix_name - a string that defines the name of the affix.

      affix_args - the arguments to use to create the affix.

      next_affix_object - the affix component that will be below the new affix
          object that we are creating in the stack.

    <Side Effects>
      None

    <Exceptions>
      AffixNotFoundError - raised if the affix has not been 
          registered yet.

      AssertionError - raised if the arguments provided is 
          of an unexpected type or value. 

    <Return>
      A affix object.    
    """

    # Sanity check.
    assert(isinstance(affix_name, str)), "Bad arg type. affix_name must be a string."
    assert(isinstance(affix_args, list)), "Bad arg type. affix_args must be a list."
    #assert(isinstance(affix_stack_object, AffixStack)), "Bad arg type. affix_stack_object must be a AffixStack."

    if affix_name not in AFFIX_CLASS_DICT.keys():
      raise AffixNotFoundError("Affix '%s' has not been registered yet." % affix_name)

    # Create a new affix object from the name and arguments provided.
    affix_object_class = AFFIX_CLASS_DICT[affix_name]

    new_affix_object = affix_object_class(next_affix_object, affix_args)

    return new_affix_object


  


  def parse_affix_string(self, affix_str):
    """
    <Purpose>
      Makes sure that the affix string provided is in the
      right format. It ensure that the parentheses all 
      match up and the input string is valid. For example,
      there should not be any other AFFIX underneath a
      branching/splitter AFFIX as branching/splitter 
      AFFIXs are considered to be at the bottom of the 
      stack.

    <Arguments>
      affix_str - a string that has the list of affixs and their
          arguments. A affix should be of the format:
         
            (AffixName,arg1,arg2,...)

    <Side Effects>
      None

    <Exceptions>
      AffixConfigError - raised if unable to parse affix string properly.

    <Return>
      A tuple that contains the first affix name, its arguments
      and the rest of the affix string.
      Example:
          ("AffixA", [argA1, argA2, argA3], "(AffixB)(AffixC,argC1)") 
    """

    # Sanity check.
    assert(isinstance(affix_str, str)), "Bad arg type. affix_str must be string."
    assert(affix_str), "affix_str must not be empty"

    open_paren_count = 0
    cur_affix_config = ""
    
    while affix_str:
      # Extract the first character of affix string.
      chr = affix_str[0]
      affix_str = affix_str[1:]

      if chr == '(':
        # The case where one of the arguments for the affix includes
	# parentheses..
        if open_paren_count != 0:
	  cur_affix_config += chr
        open_paren_count += 1
        

      elif chr == ')':
        open_paren_count -= 1

	# If there is a closed parentheses as part of the argument.
	if open_paren_count > 0:
	  cur_affix_config += chr

        # If we have uncovered a full affix config.
        elif open_paren_count == 0:
	  break

        # For the case of an extra close parentheses.
        if open_paren_count < 0:
          raise AffixConfigError("Incorrect affix string format. " +
              "Mismatched parentheses.")

      else:
        # Make sure that we have an open parentheses.
        if open_paren_count > 0:
          cur_affix_config += chr

        # This is the case where there is a character outside the
        # parentheses. An example would be:
        # '(AffixA, arg_a)foo(AffixB)', where 'foo' is not in the
        # affix config.
        else:
	  err = "Incorrect affix string format."
	  err += " Affix string provided: " + affix_str
          raise AffixConfigError(err)


    # The case where we have finished parsing the affix string and 
    # There was a mismatch of parentheses.
    if open_paren_count > 0:
      raise AffixConfigError("Incorrect affix string format. " +
          "Mismatched parentheses.")


    # Split the name and the arguments.
    affix_name = ''
    affix_arg_list = []
    paren_count = 0
    
    # Get the name out.
    while cur_affix_config:
      chr = cur_affix_config[0]
      cur_affix_config = cur_affix_config[1:]
    
      if chr != ',':
        affix_name += chr
      else:
        break

    # Split the arguments. Cant use the split command.
    cur_argument = ''
    while cur_affix_config:
      chr = cur_affix_config[0]
      cur_affix_config = cur_affix_config[1:]

      if chr == '(':
        paren_count += 1
      elif chr == ')':
        paren_count -= 1
      elif chr == ',':
        # If we are outside a affix.
        if paren_count == 0:
          # We have uncovered an argument. Add it to the
	  # list and clear the current argument.
          affix_arg_list.append(cur_argument)     
          cur_argument = ''
          continue

      # Add the character to the current argument string.
      cur_argument += chr

    # If there was a leftover last argument.
    if cur_argument:
      affix_arg_list.append(cur_argument)
      

    # Return format is: (affix_name, affix_args_list, rest_of_affix_string)
    return (affix_name, affix_arg_list, affix_str)
